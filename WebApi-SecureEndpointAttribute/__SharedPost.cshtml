@inherits Custom.Hybrid.Razor14
@{
  var page = GetService<ToSic.Sxc.Services.IPageService>();
  page.Activate("2sxc.JsCore");
}

<script type="text/javascript">
  // Use an IFFE to ensure the variables are not exposed globaly
  // See https://developer.mozilla.org/en-US/docs/Glossary/IIFE
  (() => {

    let cachedPublicKey = "todo...";

    if (!window.crypto || !window.crypto.subtle) {
      const error = "Web Cryptography API not supported in this browser.";
      console.error(error);
      alert(error);
    }

    // Function to fetch the public key from the server
    async function fetchPublicKey() {
      //- TODO: implement geting publickey from 2sxc context
      if (cachedPublicKey) {
        return cachedPublicKey;
      }
      const response = await fetch(`/publickey`);
      const publicKey = await response.text();
      cachedPublicKey = publicKey.replace(/\\r\\n/g, '\n');
      console.log(`publicKey: '${cachedPublicKey}'`);
      return cachedPublicKey;
    }

    function getSpkiDer(spkiPem) {
      const pemContents = getPemContents(spkiPem);
      console.log(`publicKey2: '${pemContents}'`);
      const binaryDerString = window.atob(pemContents);
      return str2ab(binaryDerString);
    }

    function getPemContents(spkiPem) {
      var pemContent = spkiPem;
      pemContent = removeFromStart(pemContent, "-----BEGIN PUBLIC KEY-----");
      pemContent = removeFromEnd(pemContent, "-----END PUBLIC KEY-----");
      pemContent = removeFromStart(pemContent, "\"");
      pemContent = removeFromEnd(pemContent, "\"");
      return pemContent;
    }

    function removeFromStart(content, remove) {
      return content.startsWith(remove) ? content.substring(remove.length) : content;
    }

    function removeFromEnd(content, remove) {
      return content.endsWith(remove) ? content.substring(0, content.length - remove.length) : content;
    }

    async function importPublicKey(spkiPem) {
      return await window.crypto.subtle.importKey(
        "spki",
        getSpkiDer(spkiPem),
        {
          name: "RSA-OAEP",
          hash: "SHA-256",
        },
        true,
        ["encrypt"]
      );
    }

    function str2ab(str) {
      const buf = new ArrayBuffer(str.length);
      const bufView = new Uint8Array(buf);
      for (let i = 0, strLen = str.length; i < strLen; i++) {
        bufView[i] = str.charCodeAt(i);
      }
      return buf;
    }

    function ab2str(buf) {
      return String.fromCharCode.apply(null, new Uint8Array(buf));
    }

    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      let binary = '';
      for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return window.btoa(binary);
    }

    // Function to encrypt data
    async function encryptData(data) {

      // Fetch the RSA public key from the server
      const publicKeyPem = await fetchPublicKey();

      // Import the RSA public key
      const publicKey = await importPublicKey(publicKeyPem);

      // Generate a random AES key
      const aesKey = await window.crypto.subtle.generateKey(
        {
          name: "AES-CBC",
          length: 256,
        },
        true, // extractable
        ["encrypt", "decrypt"]
      );

      // Export the AES key to raw bits
      const rawAesKey = await window.crypto.subtle.exportKey(
        "raw",
        aesKey
      );

      // Encrypt the AES key using RSA public key
      const encryptedKey = await window.crypto.subtle.encrypt(
        {
          name: "RSA-OAEP",
        },
        publicKey,
        rawAesKey
      );

      // Generate a random IV
      const iv = window.crypto.getRandomValues(new Uint8Array(16)); // 16 bytes for AES-CBC


      // Convert the data to ArrayBuffer
      const enc = new TextEncoder();
      const encodedMessage = enc.encode(data);

      // Encrypt the data using AES key
      const encryptedData = await window.crypto.subtle.encrypt(
        {
          name: "AES-CBC",
          iv: iv,
        },
        aesKey,
        encodedMessage
      );

      // Convert ArrayBuffers to base64 strings
      const encryptedKeyBase64 = arrayBufferToBase64(encryptedKey);
      const encryptedDataBase64 = arrayBufferToBase64(encryptedData);
      const ivBase64 = arrayBufferToBase64(iv);

      console.log(`data: '${data}', encryptedData: '${encryptedDataBase64}', encryptedKey: '${encryptedKeyBase64}', iv: '${ivBase64}'`);

      return { data: encryptedDataBase64, iv: ivBase64, key: encryptedKeyBase64 };
    }

    // Example usage: Encrypt form data before submission
    document.getElementById('button1').addEventListener('click', async function (event) {
      event.preventDefault();

      const data = {
        field1: document.getElementById('field1').value,
        field2: document.getElementById('field2').value
      };

      const encryptedData = await encryptData(JSON.stringify(data));
      const postData = JSON.stringify(encryptedData);

      $2sxc(@CmsContext.Module.Id).webApi
        .fetchJson('app/auto/WebApi-SecureEndpointAttribute/api/SecureEndpoint/SubmitForm', postData)
        .then(data => {
          console.log('Success:', data);
        })
        .catch((error) => {
          console.error('Error:', error);
        });
    });

  })();
</script>